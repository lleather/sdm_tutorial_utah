---
title: "Utah SDM Workshop troubleshooting and data prep"
output: html_notebook
---

Prep and planning for SDM workshop / demo to deliver to Utah Geography. 

This will be based on Dan Griffith's SDM workshop from OSU in Fall 2017. 

Planned modifications include: 

    - Shift to aspens in UT
    - Demo BRT alone instead of dismo, runs a little faster 
        - or, just run a BRT in dismo 
        - Optimize parameters before running 
       
    - Include ggmap plotting capabilities
    - envStack- bioclim - minus the categorical vars.  
- Way to make README match the handout? So people can use GitHub 


- Have users either clone or just download whole github repo 

# Setup

```{r}
# LOAD LIBRARIES
  #install.packages("here)
    library(here)
  #install.packages("rgeos")  
    library(rgeos)
  #install.packages("rgbif")
    library(rgbif)
  #install.packages("maps")
    library(maps)
  #install.packages("maptools")
    library(maptools)  
  #install.packages("raster")
    library(raster)
  #install.packages("rgdal") 
    library(rgdal) 
  #install.packages("biomod2")
    library(biomod2)
  #install.packages("ggplot2")
    library(ggplot2)
  #install.packages("tidyverse")
    library(tidyverse)



```


## Looking for the data - climate data

```{r}

#climate data

load(here("data/climate/envStack_v2.RData"))

# what's in here? 

names(envStack)
names(envStack[[1:20]])

#export to just be top 20 vars

envStack <- envStack[[1:20]]

saveRDS(envStack, file = here("data/climate/envStack_ForWorkshop.RData"))

#inspect 
envStack <- readRDS(here("data/climate/envStack_ForWorkshop.RData"))

envStack

plot(envStack)

```

Actually, the resolution of this one is not appropriate for the UT work. Let's crop and subset to UT. 

```{r}

#load UT polygon to crop to

### another different way to get state data
states_list <- c('Utah')
states_all <- getData("GADM",country="USA",level=1, path = here("data/UT"))
UT_shp <- states_all[states_all$NAME_1 %in% states_list,]

#inspect
plot(UT_shp)
UT_shp

#export
writeOGR(UT_shp, here("data/UT"), layer = "UT", driver = "ESRI Shapefile", overwrite = TRUE)

#load back in 
UT.shp <- shapefile(here("data/UT/UT.shp"))

#load 30s res envStack 

envStack30s <- stack("/Users/lilaleatherman/BoxSync/current_projects_sync/vedu_sdm/data/climate/bioclim/EnvStack30s/envStack30s.gri")

envStack30s_UT_ext <- crop(envStack30s, extent(UT_shp))
envStack30s_UT <- crop(envStack30s, UT_shp)
envStack30s_UT <- mask(envStack30s_UT, UT_shp)


plot(envStack30s_UT_ext)
plot(envStack30s_UT)
envStack30s_UT

#export - rectangle data for participants to crop 
writeRaster(envStack30s_UT_ext, file = here("data/climate/envStack_init.tif"), options = "INTERLEAVE=BAND", overwrite=TRUE)
writeRaster(envStack30s_UT_ext, file = here("data/climate/envStack_init.grd"), options = "INTERLEAVE=BAND", overwrite=TRUE)
saveRDS(envStack30s_UT_ext, file = here("data/climate/envStack_init.RData"))


#export
writeRaster(envStack30s_UT, file = here("data/climate/envStack_ForWorkshop.tif"), options = "INTERLEAVE=BAND", overwrite=TRUE)
saveRDS(envStack30s_UT, file = here("data/climate/envStack_ForWorkshop.RData"))


# check i can read in

envStack_UT <- stack(here("data/climate/envStack_ForWorkshop.tif"))

envStack_UT <- readRDS(here("data/climate/envStack_ForWorkshop.RData"))
envStack_UT

```


## Looking for the data -- species data

```{r}
#function also doesn't work if the gbif website is down
gbif.POTR <- occ_search(scientificName = "Populus tremuloides", 
                           return = "data", 
                           hasCoordinate = TRUE, 
                           hasGeospatialIssue = FALSE, 
                           limit = 200000, 
                           country = "US", stateProvince = c("Utah"), 
                           fields = c("name", "decimalLongitude", "decimalLatitude"))

colnames(gbif.POTR) <- c("name", "lon", "lat")

gbif.POTR.shp <- gbif.POTR
coordinates(gbif.POTR.shp) <- ~ lon + lat

gbif.POTR.shp <- SpatialPointsDataFrame(coords = coordinates(gbif.POTR.shp), 
                                       data = data.frame(gbif.POTR.shp))

proj4string(gbif.POTR.shp) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0") # Same as "define projection" in ArcCRAP

#check that CRS is the same as enviro data
identicalCRS(gbif.POTR.shp, envStack)

#make sure we only have points from UT
#have to do this spatial operation on a spatial object

gbif.POTR.shp <- gbif.POTR.shp[UT.shp, ]
plot(gbif.POTR.shp)

#replace file with the subsetted points in our area of interest
gbif.POTR <- gbif.POTR.shp@data %>%
  select(-optional)

#export
dir.create(path = here("/data/GBIF"))
write.csv(gbif.POTR, "./data/GBIF/gbif.POTR.csv", row.names = FALSE)
#read back in for good measure
gbif.POTR <- read.csv("./data/GBIF/gbif.POTR.csv", stringsAsFactors = FALSE)


```

## Plotting

```{r}
 

plot(gbif.POTR[,2:3])
plot(gbif.POTR.shp)

```

```{r}

#to plot points, run this whole chunk

maps::map(database = "state", regions = "utah")
    points(gbif.POTR.shp)
    

    
```

## Get data - get FIA data

sloppy download - where in FIA data are the tree species occurrence data i'm interested in ?

FIA data dictionary located here: https://www.fia.fs.fed.us/library/database-documentation/current/ver80/FIADB%20User%20Guide%20P2_8-0.pdf

```{r}

dir.create(here("data/FIA"))

#download plot file
url <- "https://apps.fs.usda.gov/fia/datamart/CSV/UT_PLOT.csv"

download.file(url, here("data/FIA/ut_plot.csv"))

ut_plot <- read.csv(here("data/FIA/ut_plot.csv"), stringsAsFactors = FALSE)

#inspect
str(ut_plot)
names(ut_plot)

#download subplot location file
url <- "https://apps.fs.usda.gov/fia/datamart/CSV/UT_SUBPLOT.csv"

download.file(url, here("data/FIA/ut_subplot.csv"))

ut_subplot <- read.csv(here("data/FIA/ut_subplot.csv"), stringsAsFactors = FALSE)

#inspect
names(ut_subplot)

#download veg subplot file
url <- "https://apps.fs.usda.gov/fia/datamart/CSV/UT_P2VEG_SUBPLOT_SPP.csv"

download.file(url, here("data/FIA/ut_spp.csv"))

ut_spp <- read.csv(here("data/FIA/ut_spp.csv"), stringsAsFactors = FALSE)

names(ut_spp)


```

```{r}
# load in FIA data tables only

ut_plot <- read.csv(here("data/FIA/ut_plot.csv"), stringsAsFactors = FALSE)
ut_subplot <- read.csv(here("data/FIA/ut_subplot.csv"), stringsAsFactors = FALSE)
ut_spp <- read.csv(here("data/FIA/ut_spp.csv"), stringsAsFactors = FALSE)

```


```{r}

#### EXAMPLE CODE

# #list plot files
# plot_files = list.files(paste0(data_dir, "raw/"), pattern="*_PLOT.csv", full.names = TRUE)
# 
# plot_df <- do.call(rbind, lapply(plot_files, function(x) read.csv(x, stringsAsFactors = FALSE)))
# 
# #list spp files
# spp_files = list.files(paste0(data_dir, "raw/"), pattern="*_P2VEG_SUBPLOT_SPP.csv", full.names = TRUE)
# 
# spp_df <- do.call(rbind, lapply(spp_files, function(x) read.csv(x, stringsAsFactors = FALSE)))
# 
# #join - should produce table with the same number of records as spp table
# fia_df <- dplyr::left_join(spp_df, plot_df, by = c("PLT_CN" = "CN",
#                                                    "STATECD" = "STATECD",
#                                                    "UNITCD" = "UNITCD",
#                                                    "COUNTYCD" = "COUNTYCD"))


# join and prepare FIA data

fia_df <- dplyr::left_join(ut_spp, ut_plot, by = c("PLT_CN" = "CN",
                                                   "STATECD" = "STATECD",
                                                   "UNITCD" = "UNITCD",
                                                   "COUNTYCD" = "COUNTYCD", 
                                                   "PLOT" = "PLOT"))

str(fia_df)

fia_df %>%
  dplyr::filter(VEG_SPCD == "POTR5")

library(tidyverse)
library(ggmap)

fia_df %>%
  group_by(PLOT) %>%
  filter(VEG_SPCD == "POTR5")

fia_df %>%
  group_by(PLOT, VEG_SPCD) %>%
  #filter(VEG_SPCD == "POTR5") %>%
  summarize(mean_cov = mean(COVER_PCT, na.rm = TRUE))
  
  
fia_df %>%
  group_by(PLOT) %>%
  mean(COVER_PCT, na.rm = TRUE)
 
# prep presence-absence data for POTR

fia_df %>%
  group_by(PLOT) %>%
  mutate(POTR5_presAbs = ifelse(VEG_SPCD %in% c("POTR5"), 1, 0)) %>%
  arrange(PLOT) %>%
  select(PLOT, VEG_SPCD, COVER_PCT, POTR5_presAbs, LON, LAT) %>%
  distinct(PLOT, POTR5_presAbs, LON, LAT)

POTR_presAbs <- 
  fia_df %>%
  group_by(PLOT) %>%
  mutate(presAbs = ifelse(VEG_SPCD %in% c("POTR5"), 1, 0)) %>%
  arrange(PLOT) %>%
  select(PLOT, VEG_SPCD, COVER_PCT, presAbs, LON, LAT) %>%
  distinct(PLOT, presAbs, LON, LAT) %>%
  rename(lon = LON, 
         lat = LAT) %>%
  arrange(PLOT)
  

POTR_presAbs

#export

write.csv(POTR_presAbs, file = here("data/FIA/FIA_POTR_UT_presAbs.csv"), row.names = FALSE)

# read back in 
fia.POTR <- read.csv(here("data/FIA/FIA_POTR_UT_presAbs.csv"), stringsAsFactors = FALSE)

fia.POTR

```

```{r}
# convert FIA data to shapefile as an example

#set up a file to convert to shapefile
fia.POTR.shp <- fia.POTR %>%
  select(-PLOT)

coordinates(fia.POTR.shp) <- ~ lon + lat

fia.POTR.shp <- SpatialPointsDataFrame(coords = coordinates(fia.POTR.shp), 
                                         data = data.frame(fia.POTR.shp))

#this field gets created; we don't care about it
fia.POTR.shp@data$optional <- NULL
 
proj4string(fia.POTR.shp) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0") # Same as "define projection" in ArcCRAP


#export
writeOGR(obj = fia.POTR.shp, dsn = here("data/FIA"), layer = "fia.POTR", driver = "ESRI Shapefile", overwrite_layer = TRUE)

#read back in 
fia.POTR.shp <- shapefile(here("data/FIA/fia.POTR.shp"))



```


```{r}
# read shapefile back in 

fia.POTR.shp <- raster::shapefile(here("data/FIA/fia.POTR.shp"))

#inspect
#plot(fia.POTR, col = presAbs)

#fia.POTR



```


Load prelim map data

```{r}
#load map data
states_us <- map_data("state")

UT <- subset(states_us, region %in% c("utah"))

fia_df %>%
  group_by(PLOT) %>%
  filter(VEG_SPCD == "POTR5") %>%
ggplot() + 
      geom_polygon(data = UT, aes(x=long, y = lat, group = group), fill = NA, color = "black") +
      geom_point( aes(x = LON, y = LAT), color = "red") +
      coord_fixed(1.3) + 
      labs(title = "FIA POTR5 PRESENCE DATA")

fia_df %>%
  group_by(PLOT) %>%
  mutate(POTR5_presAbs = ifelse(VEG_SPCD %in% c("POTR5"), 1, 0)) %>%
  arrange(PLOT) %>%
  select(PLOT, VEG_SPCD, COVER_PCT, POTR5_presAbs, LON, LAT) %>%
  distinct(PLOT, POTR5_presAbs, LON, LAT) %>%
  arrange(POTR5_presAbs) %>%
ggplot() + 
      geom_polygon(data = UT, aes(x=long, y = lat, group = group), fill = NA, color = "black") +
      geom_point( aes(x = LON, y = LAT, color = factor(POTR5_presAbs))) +
      coord_fixed(1.3) + 
      labs(title = "FIA POTR5 PRESENCE DATA")

```

```{r}
# make GBIF and FIA data play with each other

#FIA data already have presence-absence data, need to add it for GBIF

gbif.POTR.shp@data <- data.frame(gbif.POTR.shp@data,
                                 presAbs = rep(1, nrow(gbif.POTR.shp)))

# bind these together
POTR.dat <- bind_rows(fia.POTR.shp@data, gbif.POTR.shp@data) %>%
  select(lon, lat, presAbs) # filter to only the fields present in both datasets 

# since we already have both as data frames, another option is to just bind the original dataframes, and not the data portion of the spatial points data frame

#still have to add presAbs to gbif
gbif.POTR <- gbif.POTR %>%
  mutate(presAbs = 1)

POTR.dat.2 <- bind_rows(fia.POTR, gbif.POTR) %>%
  select(lon, lat, presAbs)

# plot all together

ggplot() +
      geom_polygon(data = UT, aes(x=long, y = lat, group = group), fill = NA, color = "black") +
      geom_point(data = POTR.dat %>% arrange(presAbs), aes(x = lon, y = lat, color = factor(presAbs))) +
      coord_fixed(1.3) + 
      labs(title = "FIA and GBIF PRESENCE/ABSENCE DATA - Populus tremuloides")

plot(gbif.POTR.shp)

```

## load and prep landcover layer to use to mask SDM to forested areas only

```{r}

landcover <- raster(here("data/ut_landcover/ut_landcover.tif"))

#inspect
plot(landcover)

landcover

summary(landcover)

#list forest landcover classses
# from metadata

forest_classes <- c(23:26, 28:40, 42, 51, 111:112, 121:123, 125)

forest_mask <- landcover %in% forest_classes

plot(forest_mask)

forest_mask_wgs <- projectRaster(forest_mask, crs = crs(envStack_UT),
                                 res = res(envStack_UT))

compareRaster(forest_mask_wgs, envStack_UT)
extent(forest_mask_wgs)
extent(envStack_UT)

forest_mask_wgs <- projectRaster(forest_mask, envStack_UT)

forest_mask_wgs
compareRaster(forest_mask_wgs, envStack_UT)

#export 
writeRaster(forest_mask_wgs, here("data/ut_landcover/ut_forestmask.tif"), format = "GTiff", overwrite = TRUE)

#read back in

forest_mask_wgs <- raster(here("data/ut_landcover/ut_forestmask.tif"))

forest_mask_wgs
plot(forest_mask_wgs)

```

## mask data for forest

```{r}
envStack_mask <- mask(x = envStack_UT, mask = forest_mask_wgs)

plot(envStack_mask)

```
This is so irregular, I don't think we want this for this project. 


```{r}
gbif.POTR.shp@data <- data.frame(presAbs = rep(1, nrow(gbif.POTR.shp)))
fia.POTR.shp@data <- data.frame(presAbs = fia.POTR.shp@data$presAbs)

POTR.dat.shp <- rbind(fia.POTR.shp, gbif.POTR.shp)

POTR.dat.shp <- spTransform(POTR.dat.shp, proj4string(envStack_UT))

plot(envStack_UT[[1]])
    points(POTR.dat.shp, pch = 21, bg = "white", cex = 0.5)
    points(POTR.dat.shp[POTR.dat.shp$presAbs == 1,], pch = 21, bg = "dodgerblue")



```


```{r}

## extract enviro data to points

env.dat <- raster::extract(x = envStack_UT, y = POTR.dat.shp)
head(env.dat)
    #plot(env.dat[,2] ~ factor(POTR.dat.shp$presAbs))

```

### Next 

```{r}
POTR.mod.dat <- BIOMOD_FormatingData(resp.var = as.numeric(POTR.dat$presAbs),
                                     resp.xy = POTR.dat[, c("lon", "lat")],
                                     #resp.var = POTR.dat.shp, # for input: can use shapefile with the presence-absence response in the @data slot
                                     expl.var = stack(envStack_UT),
                                     #eval.resp.var = ,
                                     #PA.strategy = "random", 
                                     #PA.nb.rep = 0, 
                                     #PA.nb.absences = 0,
                                     resp.name = "Populus.tremuloides")
POTR.mod.dat

BIOMOD_ModelingOptions() # need to install java in order to run Maxent.Phillips; we won't be doing this today because it can be pretty finicky!
#myBiomodOptions <- BIOMOD_ModelingOptions(MAXENT.Phillips = list(path_to_maxent.jar = "maxent/maxent.jar"))

POTR.mod <- BIOMOD_Modeling(data = POTR.mod.dat, 
                            #models = c('GLM','GAM','ANN','RF','MAXENT.Tsuruoka'),  
                            models = c('GBM','ANN','RF'), 
                            #SaveObj = TRUE,
                            #models.options = myBiomodOptions,
                            # , DataSplit = 80
                            VarImport = 1)

POTR.mod
```

## Get model evaluations

```{r}

POTR.mod.eval <- get_evaluations(POTR.mod)
    dimnames(POTR.mod.eval)
    POTR.mod.eval["TSS","Testing.data",,,]
    POTR.mod.eval["KAPPA","Testing.data",,,]
    POTR.mod.eval["ROC","Testing.data",,,]
    
# prep and plot these data a little more attractively
    
POTR.mod.eval <- 
     data.frame(POTR.mod.eval[1:3, 1:4, ,,]) %>%
       rownames_to_column("metric") %>%
       gather(-metric, key = "mod", value = "val") %>%
       mutate(mod = gsub(pattern = "Testing.data", "Testingdata", mod)) %>%
       separate(mod, c("val_type", "model"))

#inspect evaluation statistics
print(
POTR.mod.eval %>%
  filter(val_type == "Testingdata") %>%
  ggplot(aes(x = metric, y = val, fill = model)) +
  geom_bar(stat = "identity", position = "dodge") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  labs(title = "model evaluation - on testing data",
       x = "model type")
) 

    
```

## Get variable importance 

```{r}
get_variables_importance(POTR.mod)

```
 We can also prep and plot this a little more attractively. 
 
```{r}
# investigate variable importance
# still some parsing to do here to visualize
var.imp <- (get_variables_importance(POTR.mod))
var.imp <- data.frame(var.imp)
# var.imp$var <- names(envStack_aoi)
# var.imp

var.imp <-
  var.imp %>%
  mutate(var = names(envStack_UT))%>%
  gather(-var, key = "mod", value = "val") %>%
  separate(mod, c("model_type", "model_level", "data_amt")) 

#plot var importance
print(
var.imp %>%
  #mutate(val = ifelse(model_type == "RF", val*10, val)) %>% #multiply RF values by 10 to compare better? idk why these are so low
  ggplot(aes(y = val, x = reorder(var, val), fill = val, group = interaction(data_amt, model_type))) +
  geom_bar(stat = "identity", position = "dodge") + 
  coord_flip() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  labs(title = "Variable importance, by model",
       x = "variable") + 
  facet_grid(~model_type)
)

```
## Create an ensemble model-- averaging all of the models together

```{r}

myBiomodEM <- BIOMOD_EnsembleModeling(
                  modeling.output = POTR.mod,
                  chosen.models = 'all',
                  em.by= 'all',
                  eval.metric = c('TSS'),
                  eval.metric.quality.threshold = c(0.6),
                  prob.mean = T,
                  prob.cv = T,
                  prob.ci = T,
                  prob.ci.alpha = 0.05,
                  prob.median = T,
                  committee.averaging = T,
                  prob.mean.weight = T,
                  prob.mean.weight.decay = 'proportional')

myBiomodEM
get_evaluations(myBiomodEM)

```

## Project the model spatially

```{r}

myBiomodProj <- BIOMOD_Projection(modeling.output = POTR.mod,
                    new.env = stack(envStack_UT),
                    proj.name = 'current' ,
                    selected.models = 'all' , # will return separate projections for each model 
                    binary.meth = 'TSS' ,
                    compress = 'xz' ,
                    clamping.mask = F,
                    output.format = '.grd' )

myBiomodProj

plot(myBiomodProj)

```
```{r}
plot(myBiomodProj, str.grep = 'RF' )

```

```{r}

myCurrentProj <- get_predictions(myBiomodProj)

presentResult <- calc(myCurrentProj,fun = median); #Choose whatever descriptive statistic you'd like
plot(presentResult)

myCurrentProj
plot(myCurrentProj)

```

This is the output that you can save and manipulate. 

```{r}
# save raster
writeRaster(presentResult, filename = paste0(proj_dir, "data/model_output/map_predictions/maxent_pa_random_bme_ras.tif"), format = "GTiff", overwrite = TRUE)

```


## Making attractive maps with R and ggplot

### Static maps: using ggplot and colorblind-friendly color schemes

ggplot2 can also be used to make maps, without the ggmap package. I like this because it allows you to plot points (and even polygons!) over a raster layer, and customize how your raster looks, in ways that I think are easier to understand than in base R (e.g., plot() ).. However, there are a few additional data processing steps here, so it's less well-suited for on-the-fly visualization. 

We're also using the [viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) package for this rockin color scheme. Unlike other color schemes, which often rely on distinctions between green and red, viridis supplies a variety of color schemes that have gradations that are perceptible to folks who can't easily perceive the difference between green and red. 

This uses the gplot() (not ggplot()) command from the rasterVispackage, which is a wrapper around ggplot to use with raster data. A more detailed tutorial for plotting raster data in R is located [here](http://zevross.com/blog/2015/03/30/map-and-analyze-raster-data-in-r/).

This first method requires little data processing, but produces maps that sometimes look striated when I render them to export in markdown. (Not sure why! Something weird with the mapping?) 

Importantly, you'll notice that the spatial resolution of the basemap is only as good as the raster data that you're visualizing.

First, we'll choose one of our models to visualize. 

```{r}
#select one layer from the raster stack output
RF_model <- myCurrentProj$Populus.tremuloides_AllData_Full_RF
```


```{r static maps with geom tile, message = FALSE}

library(rasterVis)
library(viridis)

p = gplot(RF_model) +
  #geom_polygon(data = ks, aes(x=long, y = lat, group = group), fill = NA, color = "black", size = 1) +
  geom_tile(aes(fill = value)) + 
  scale_fill_viridis(na.value = "white") + 
  theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  coord_fixed(ratio = 1.3) # sets the xy resolution to a constant value

p

```

We can also plot our initial points over this model. 

```{r}

p + geom_point(POTR.dat %>% arrange(presAbs) %>% filter(presAbs == 1),
             mapping = aes(x = lon, y = lat, col = factor(presAbs)), shape = 21, color = "white", size = 1) + 
  labs(title = paste0("Aspen occurrence data"))  
  

```

A mapmaking method that requires a little more data prep-- but generates smoother-looking maps on the fly-- is to convert your raster data set to a data frame of points, with a value for each lat-long combination in the data set. This is in contrast to a raster, which is essentially a matrix of data. Confusingly, the geom_raster() function cannot plot an actual raster! 

```{r static maps with geom raster}

#write function to convert raster to ggplot-friendly format
raster_to_pts_gg <- function(raster) {
  spdf <- as(raster, "SpatialPixelsDataFrame")
  df <- as.data.frame(spdf)
  colnames(df) <- c("value", "x", "y")
  df
}

#convert selected raster to list of points
RF_model_pts <- raster_to_pts_gg(RF_model)

#plot
p = ggplot() + 
  geom_raster(data = RF_model_pts, aes(x = x, y = y, fill = value)) + 
  scale_fill_viridis() + 
  #remove default plotting background
  theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  coord_fixed(ratio = 1.3)

p

p + 
  geom_point(POTR.dat %>% arrange(presAbs) %>% filter(presAbs == 1),
             mapping = aes(x = lon, y = lat, col = factor(presAbs)), shape = 21, color = "white", size = 1) + 
  labs(title = paste0("Aspen occurrence data"))  


```

## Leaflet

Mapmaking capabilities in R aren't just limited to static maps-- there are a couple different utilities for making interactive maps in R. The widely-used mapping software [Leaflet](https://leafletjs.com/index.html) can be used in R.

I referred to [this useful demo](https://gbif-europe.github.io/nordic_oikos_2018_r/s3_gbif_demo/gbif_demo.html) for downloading gbif data in R, and then visualizing using leaflet.

First, we need to make sure that the appropriate packages are installed. [mapr](https://cran.r-project.org/web/packages/mapr/index.html) has a simple leaflet mapping utility that we'll install. Conveniently, mapr can take data frames as an input. There is also [Leaflet R package](https://rstudio.github.io/leaflet/).

```{r leaflet in R via mapr }
install.packages("mapr")
library(mapr)

#commented out for rendering to pdf
#visible only in .html format

#map only presences

POTR.dat %>%
  #map_leaflet() needs the species name to be "name"
  mutate(name = "Populus tremuloides") %>%
  #filter to just show presences here
  filter(presAbs == 1) %>%

  map_leaflet(., "lon", "lat", size=2)

```

[link to screenshot of map]

In the interactive map, you can zoom in and out, and mouse over / click on your occurrence points to see data about them. 

Here's a [much more complex Leaflet tutorial](http://strimas.com/r/ebird-county/) that uses specifically eBird data, mapped in R using Leaflet. 

The full leaflet package provides a lot of options to customize your map baselayers, markers, and labels, which are detail in the Leaflet R package tutorial. Without getting too complicated, here's a very simple way to visualize your data in R.

```{r leaflet in R via leaflet}
#install.packages("leaflet")
library(leaflet)

#commented out for rendering to pdf
#visible only in .html format

#filter data to only include presences
#similarly, this takes a lot of time to render when we have this much data.
POTR.dat %>%
  filter(presAbs == 1) %>%
  leaflet() %>%
  addTiles() %>%
  #simple, default markers where you set what shows when you mouse over ("label") and click on ("popup") a point.
  addMarkers(~lon, ~lat, popup = ~as.character(presAbs), label = ~paste0("Presence: ", as.character(presAbs)))

```

[include screenshot of map for pdf]

### Plotting points: using a google-derived basemap

ggmap is a package you can use to download satellite imagery. 

You may need to update other packages on this install. 

```{r}
#install.packages("devtools")
library(devtools)
devtools::install_github("dkahle/ggmap")
library(ggmap)

```


Google provides a way to access baselayers for plotting your points on a map. But, it can throw a lot of errors!


```{r}
library(ggmap)

map = get_map(location = "utah",
              zoom = 6,
              source = "google",
              maptype = "satellite")

p = ggmap(map)
p +
  geom_point(POTR.dat %>% arrange(presAbs),
             mapping = aes(x = lon, y = lat, col = factor(presAbs))) +
  labs(title = paste0("POTR presence and absence"))
```

## Using alternate baselayer sources for maps

An easy way to get around the errors from google maps is just to change the source of the get_map() command. Because google is the default, we have to specify a different source.

### Stamen maps

[Stamen](http://maps.stamen.com/#terrain/12/37.7706/-122.3782) is a data visualization utility provides a few different options for map baselayers-- that are easier to query than google. Similar to the google maps, you're also downloading map tiles from an online utility-- but the stamen maps tend to be less finicky and proprietary.

To use them, use the command get_map(), but set source to "stamen".

You can also read more about the different sources and maptypes in the [documentation for the ggmap package.](https://cran.r-project.org/web/packages/ggmap/ggmap.pdf) 

```{r}
library(ggmap)
map = get_map(location = "Utah",
              zoom = 6,
              source = "stamen")

p = ggmap(map)
p +
  geom_point(POTR.dat %>% arrange(presAbs),
             mapping = aes(x = lon, y = lat, col = factor(presAbs))) +
  labs(title = paste0("POTR presence and absence"))
```


Also, show a few different options for making cute maps in R - from SDM class bit 
 
